#show table: it => {
  set text(size: 11pt)
  set par(first-line-indent: 0em)
  set list(indent: 0em)
  set enum(indent: 0em)
  it
}

#figure(
  table(
    columns: (0.16fr, 0.3fr, 0.15fr, 1fr),
    align: (center, center, center, left),
    fill: (x, y) => if y == 0 { luma(220) } else { white },
    stroke: 0.5pt + black,

    [*Смещение*], [*Поле*], [*Размер*], align(center)[*Описание*],

    [0],
    [FIN],
    [1],
    [
      - 1 = *финальный фрейм* сообщения.
      - 0 = сообщение фрагментировано и это *не финальный фрейм*.
    ],

    [1],
    [RSV1],
    [1],
    table.cell(rowspan: 3)[
      *Зарезервировано. Должно быть 0*, если не определено расширением.
      Если получено ненулевое значение и ни одно из согласованных расширений не
      определяет значение такого ненулевого значения, соединение должно быть
      закрыто.
    ],

    [2], [RSV2], [1],

    [3], [RSV3], [1],

    [4],
    [Opcode],
    [4],
    [
      См. опкоды ниже.
    ],

    [8],
    [Masked\ (Маскирован)],
    [1],
    [
      - *1 = фрейм маскирован* (т.е. присутствует ключ маскирования и полезная
        нагрузка была обработана XOR с ключом маскирования).
      - *0 = фрейм не маскирован* (т.е. ключ маскирования отсутствует).
    ],

    [9],
    [Payload length\ (Длина нагрузки)],
    [7, 7+16\ или 7+64],
    [
      *Длина полезной нагрузки* (данные расширения + данные приложения) в байтах.
      - *0–125* = Это длина полезной нагрузки.
      - *126* = Следующие 16 бит — это длина полезной нагрузки.
      - *127* = Следующие 64 бита (старший бит должен быть 0) — это длина
        полезной нагрузки.

      Порядок байтов — *big-endian*. Знаковость — *беззнаковая*. Для кодирования
      длины должно использоваться *минимальное* количество бит.
    ],

    [Варьируется],
    [Masking key \ (Ключ маскирования)],
    [0 или 32],
    [
      *Случайный nonce*. Присутствует, если поле masked равно 1. Клиент
      генерирует ключ маскирования для каждого маскированного фрейма.
    ],

    [Варьируется],
    [Payload: \ Данные расширения],
    table.cell(rowspan: 2)[Payload \ length\ (байты)],
    [
      *Должно быть пустым*, если не определено расширением.
    ],

    [Варьируется],
    [Payload: \ Данные  приложения],
    [
      Зависит от opcode
    ],
  ),
  caption: [Структура фрейма],
)

#figure(
  table(
    columns: (0.27fr, 0.12fr, 0.12fr, 1fr, 0.23fr, 0.05fr, 0.28fr),
    align: (center, center, center, center, left, center + horizon, center + horizon, center),
    fill: (x, y) => if y == 0 { luma(220) } else { white },
    stroke: 0.5pt + black,

    table.cell(colspan: 2)[*Тип фрейма*],
    [*Opcode*],
    [*Описание*],
    [*Назначение*],
    rotate(90deg)[*Фраг.*],
    [*Макс. размер нагрузки (байты)*],

    table.cell(colspan: 2)[Continuation\ (Продолжение)],
    [0],
    [ Не первый фрейм фрагментированного сообщения.  ],
    [Фрагментация\ сообщения],
    [],
    table.cell(rowspan: 4)[$2^63 - 1$],

    table.cell(rowspan: 3)[Не управляющий\ фрейм],
    [Text],
    [1],
    [ Текст в кодировке UTF-8.  ],
    table.cell(rowspan: 2)[Сообщение\ с данными],
    table.cell(rowspan: 3)[*$+$*],

    [Binary],
    [2],
    [ Бинарные данные.  ],
    [],
    [3–7],
    [*Зарезервировано* для будущих не управляющих фреймов. Может быть определено
      расширением.],
    [],

    table.cell(rowspan: 4)[Управляющий\ фрейм],
    [Close],
    [8],
    [
      WebSocket *процедура закрытия начинается при отправке или получении фрейма
      Close*. Это может предотвратить потерю данных, дополняя процедуру закрытия
      TCP. После отправки фрейма Close никакие фреймы отправлять нельзя. Если
      получен фрейм Close и ранее не был отправлен фрейм Close, в ответ должен
      быть отправлен фрейм Close (обычно с эхом полученного кода состояния).
      Полезная нагрузка необязательна, но если присутствует, должна начинаться с
      двухбайтового big-endian беззнакового целого *кода состояния*, за которым
      может следовать сообщение-причина в кодировке UTF-8 длиной не более 123
      байт.
    ],
    table.cell(rowspan: 4)[Состояние\ протокола],
    table.cell(rowspan: 4)[*$-$*],
    table.cell(rowspan: 4)[125],

    [Ping],
    [9],
    table.cell(rowspan: 2)[
      Может использоваться для измерения задержки, keepalive и heartbeat. Обе
      стороны могут *отправить ping* (с любой полезной нагрузкой). Получатель
      должен как можно скорее *отправить обратно pong с той же полезной
      нагрузкой*. Pong следует игнорировать, если не был отправлен
      предварительный ping.
    ],
    [Pong], [10],

    [],
    [11–15],
    [*Зарезервировано* для будущих управляющих фреймов. Может быть определено
      расширением.],
  ),
  caption: [Опкоды фрейма],
)
