== 3.1 История и назначение протокола WebSocket

В данном разделе речь пройдёт о работе протокола WebSocket. Как уже было
сказано ранее, этот протокол работает на базе TCP и позволяет осуществить
двустороннюю передачу конечных бинарных и текстовых сообщений между клиентом и
сервером.

Впервые название WebSocket появилось в июне 2008 года в спецификации HTML5. 
Первым браузером, который включал поддержку протокола, стал Google Chrome в
декабре 2009 года. Позже, в декабре 2011 года протокол был включён в стандарт
RFC №6455@rfc6455 и стал доступен в основных браузерах.

== 3.2 Принцип работы WebSocket

Протокол включает в себя следующие шаги:

1. Открывающее рукопожатие.
2. Обмен сообщениями.
3. Закрывающее рукопожатие.

=== Открывающее рукопожатие

Клиент отправляет серверу HTTP запрос и сервер отвечает кодом 101 (смена
протокола) в случае успеха. @websocket-http-request показывает пример
минимального запроса для открытия подключения. 

#figure(
  ```http
  GET /chat HTTP/1.1
  Host: infotab.pgups.ru
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
  Origin: https://infotab.pgups.ru
  Sec-WebSocket-Protocol: chat, superchat
  Sec-WebSocket-Version: 13
  ```,
  kind: image,
  caption: [Пример HTTP запроса для открытия WebSocket подключения]
) <websocket-http-request>

@websocket-http-response в свою
очередь - пример ответа сервера, означающий успешное выполнение рукопожатия. 

#figure(
  ```http
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
  Sec-WebSocket-Protocol: chat
  ```,
  kind: image,
  caption: [Пример HTTP ответа сервера об успешном переходе на протокол WebSocket]
) <websocket-http-response>

=== Обмен сообщениями

После успешного рукопожатия, клиент и сервер могут в любое время отправлять 
сообщения, которые состоят из _фреймов_. Структура фрейма показана в приложении 
@sup-websocket. Нефрагментированные сообщения состоят из одного фрейма с
$"FIN"=1$ и $"opcode" != 0$.
Фрагментированные сообщения состоят из нескольких фреймов:
- начальный фрейм с $"FIN"=0$ и $"opcode" != 0$;
- последовательность фреймов с $"FIN"=0$ и $"opcode" = 0$;
- конечный фрейм с $"FIN"=1$ и $"opcode" = 0$.

Клиент должен применять маскирование для всех фреймов, отправляемых на сервер,
в то же время сервер этого делать не должен. Маскирование - это выполнение
операции побитового взаимоисключающего или между данными фрейма и маской.
Процедура маскирования показана на рисунке 
#ref(label("frame-gamming"), supplement: none).

#figure(
  ```python
  for i from 0 to payload_length − 1
     payload[i] := payload[i] xor masking_key[i mod 4]
  ```,
  kind: image,
  caption: [Процедура маскирования фреймов]
) <frame-gamming>

=== Закрывающее рукопожатие

Для выполнения рукопожатия клиент или сервер отправляет фрейм с $"opcode" = 8$
(закрывающий фрейм). После отправки закрывающего фрейма никакие фреймы не могут
быть отправлены. После получения закрывающего фрейма отправляется в ответ
закрывающий фрейм. Закрывающий фрейм может включать в себя данные с причиной
закрытия и должен содержать статусный код 1000 в случае нормального закрытия
или иной в других случаях.
