== 1.1 Выбор сетевых технологий и оборудования

В работе системы диспетчеризации очень важны производительность и надёжность при
передаче сообщений между её устройствами. Стек TCP/IP является стандартным
выбором для организации сетей любой сложности и отвечает этим требованиям
системы диспетчеризации.  Протокол TCP обеспечивает передачу данных с
подтверждением получения и сохранением правильности порядка пакетов, сохраняя
низкое значение времени задержки.

Устройства (планшеты) подключаются в сеть с помощью 8-контактного кабеля Ethernet
с поддержкой PoE. Это позволяет подводить к каждому устройству только один
кабель и для питания, и для подключения в сеть, что упрощает монтажные работы
и уменьшает их стоимость и сроки.

Для упрощения взаимодействия между сервером и устройствами отображения выбран
протокол WebSocket. Хотя изначальное его применение задумывалось для создания
безопасного соединения и обмена сообщениями между браузером и веб-сервером,
протокол оказался удобен и за пределами веб-разработки. WebSocket сочетает в
себе удобство конечных сообщений UDP и надёжность TCP.

Помимо этого сервер может работать по протоколам HTTP и HTTPS, что позволяет 
сторонним приложениям обращаться к нему (например для получения данных о 
сотрудниках организации или расписании занятий).


== 1.2 Выбор языка программирования

Многие современные проекты часто используют такие языки, как: Java, C\#, C++,
JavaScript, Python. В то же время Rust остаётся весьма непопулярным выбором. По
данным StackOverflow, с Rust работало лишь 14.8% программистов @stack-overflow. Почему же он выбран в проекте системы диспетчеризации информации?

Одним из важных преимуществ языка для разработки сложных систем является его
богатая система типов. Обработка ошибок, времена жизни, перегрузка операторов,
многопоточная безопасность, обобщения, инварианты и алгебраические данные
существуют исключительно в рамках системы типов. Использование этих концепций
позволяет исключать многие логические ошибки и ошибки, связанные с безопасностью
и управлением потоком программы@rust-postgres. Такие частые ошибки программистов
в Java, как NullReferenceException, условия гонки и утечки ресурсов просто
невозможны в Rust. @rust-result показывает пример контролируемой обработки
ошибок. Тип Result во многом похож на проверяемые исключения в Java, однако
предлагает гораздо более мощные инструменты для работы с ошибками.

#figure(
  ```rs
  fn write_info(info: &Info) -> io::Result<()> {
      let mut file = File::create("my_best_friends.txt")?;
      file.write_all(format!("name: {}\n", info.name).as_bytes())?;
      file.write_all(format!("age: {}\n", info.age).as_bytes())?;
      file.write_all(format!("rating: {}\n", info.rating).as_bytes())?;
      Ok(())
  }
  ```,
  kind: image,
  caption: [Пример использования Result]
) <rust-result>

Помимо этого, в языке имеется первоклассная поддержка модульного и
интеграционного тестирования, что позволяет легко проверять логику приложения,
которую невозможно проверить на этапе компиляции. @rust-unit показывает
минимальный код, который необходимо написать разработчику для создания теста.

#figure(
  ```rs
  fn add(a: u32, b: u32) -> u32 { a + b }

  #[cfg(test)]
  mod tests {
    use super::*;

    #[test]
    fn test_add_works() {
      assert_eq(add(2, 2), 4);
    }
  }
  ```,
  kind: image,
  caption: [Модульное тестирование в Rust],
) <rust-unit>

В то же время, у языка есть и множество недостатков. Одним из самых сильных
является его высокая сложность изучения. Разработчику требуется много времени
на то, чтобы стать эффективным в использовании языка. Также не рекомендуется
его изучение начинающим разработчикам без опыта программирования. Тем не менее,
автор текста считает, что при разработке сложных систем сложность языка
программирования выходит на второй план.

== 1.3 Сторонние библиотеки сервера

Для разработки сервера и его API использованы следующие библиотеки:

- *axum*: HTTP-фреймворк;
- *rustls*: реализация TLS на Rust;
- *serde*: сериализация и десериализация;
- *sqlx*: драйвер базы данных;
- *tokio*: асинхронная среда выполнения;
- *tracing*: статистика и логирование;
- *tungstenite*: серверные функции для протокола WebSocket;
- *utoipa*: генерация спецификации в формате OpenAPI.

== 1.4 Сторонние библиотеки клиента

Для разработки клиента для устройств отображения использованы следующие
библиотеки:

- *eframe*: фреймворк для запуска egui на разных платформах;
- *egui*: библиотека непосредственного режима#footnote[Immediate Mode UI --
  парадигма, при которой интерфейс вычисляется заново каждый кадр]
  для разработки интерфейсов;
- *ewebsock*: простая асинхронная реализация WebSocket для клиента;
- *jni*: привязки к Java Native Interface;
- *rustls*: реализация TLS на Rust;
- *serde*: сериализация и десериализация;
- *tracing*: статистика и логирование.
