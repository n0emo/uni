== 2.1 Организация файлов исходного кода

Существует множество способов организации кода в C/C++ проектах -- стандарт
никак не описывает, каким образом разработчику следует хранить и собирать
исходный код его проекта. Можно с уверенностью сказать, что сколько в мире
программистов на C -- столько и способов организации.

Для разработки текущего проекта был выбран один из популярных способов
организации для библиотек: заголовочные файлы располагаются в папке
include/\<название_библиотеки>, а файлы реализации -- в src.

В то же время, компиляция библиотеки организована не самым популярным образом.
Для компиляции выбрана техника "одной единицы трансляции" (англ. single
translation unit)@unity-build-austin @unity-build-ic.
С помощью директивы препроцессора \#include файл src/all.c
(см. рисунок #ref(label("all-c"), supplement: none)) подключает в себя все
остальные файлы библиотеки. Таким образом для компиляции всей библиотеки
достаточно скомпилировать один этот файл одним вызовом компилятора

#figure(
  ```c
  #include "containers.c"
  #include "core.c"
  #include "html.c"
  #include "http.c"
  #include "ini.c"
  #include "log.c"
  #include "thrdpool.c"
  ```,
  kind: image,
  caption: [Единственная единица трансляции библиотеки]
) <all-c>

Стоит отметить, что не обязательно подключать каждый файл библиотеки именно в src/all.c.
Путём использования директивы include мгогие файлы образуют дерево зависимостей.
Преимуществом такой техники является значительное ускорение чистой сборки,
поскольку отпадает необходимость избыточной компиляции заголовочных файлов
стандартной библиотеки для каждой единицы трансляции, то есть для каждого
отдельного файла при традиционной модели сборки.

Помимо упрощения процесса сборки, эта техника позволяет упростить и модель
условной компиляции. Например, файл src/core/os.c (см. рисунок 
#ref(label("core-os-c"), supplement: none)) подключает разные файлы
реализации в зависимости от целевой ОС.

#figure(
  ```c
  #ifdef _WIN32
      #include "os/socket_windows.c"
      #include "os/fs_windows.c"
      #include "os/threads_windows.c"
  #else
      #include "os/fs_posix.c"
      #include "os/socket_posix.c"
      #include "os/threads_posix.c"
  #endif
  
  #include "os/threads.c"
  #include "os/utils.c"
  ```,
  kind: image,
  caption: [Условная компиляция файлов для разных ОС]
) <core-os-c>

== 2.2 Разработка CMake файлов

Пожалуй, самой общепринятой на данный момент системой сборки для проектов на
языках C и C++ является CMake@cmake. Его поддерживают все современные
интегрированные среды разработки и редакторы исходного кода. Включение файлов
CMake в состав библиотеки значительно упрощает её использование и разработку.

Для разрабатываемой библиотеки выбрана иерархическая структура. @cmakelists
показывает структуру основного файла CMake, в котором можно видеть определение
библиотеки mew и подключение поддиректорий tests и examples, в которых
присутствуют свои CMake файлы для определения модульных тестов и примеров кода
соответственно.

#figure(
  ```cmake
  cmake_minimum_required(VERSION 3.1...3.10)
  set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

  project(mew)

  include(CTest)
  enable_testing()
  add_subdirectory(tests)
  add_subdirectory(examples)

  set(CMAKE_C_STANDARD 11)
  if(MSVC)
      add_compile_options(/W4)
  else()
      add_compile_options(-g -Wall -Wextra -Werror -O2)
  endif()
  add_library(mew STATIC ./src/all.c)
  target_include_directories(mew PUBLIC ./include/)
  ```,
  kind: image,
  caption: [CMakeLists.txt в корне проекта]
) <cmakelists>

Для использования разрабатываемой библиотеки пользователю будет достаточно
добавить определение FetchContent@fetch-content в файл CMake своего проекта и
указать mewlib в списке целей для компоновки.
