= 1. Архитектурные решения

== 1.1 Модель компонентов WebAssembly

WebAssembly Component Model расширяет базовый WebAssembly набором возможностей
для создания композируемых модулей. В отличие от классических WASM-модулей,
компоненты имеют строго типизированные интерфейсы, описанные на языке WIT
(WebAssembly Interface Types) @interface-types. Это позволяет компилятору
проверять совместимость компонентов на этапе компоновки.

В проекте wassel используется интерфейс wassel:plugin/http-plugin 
(рисунок @img-world), который определяет контракт между сервером и плагином.
Плагин должен экспортировать функцию get-endpoints, возвращающую список пар
путь-обработчик, а также реализовать функции-обработчики для каждого
зарегистрированного эндпоинта. Такая модель даёт гибкость в выборе языка
реализации при сохранении единого интерфейса.

#figure(
  caption: [Описание мира "plugin"],
  kind: image,
  ```
  package wassel:plugin;

  interface http-plugin {
      use wasi:http/types@0.2.3.{incoming-request, response-outparam};
      record endpoint { path: string, handler: string }
      get-endpoints: func() -> list<endpoint>;
  }

  world exports {
      include wasi:cli/imports@0.2.3;
      include wasi:clocks/imports@0.2.3;
      include wasi:config/imports@0.2.0-draft;
      include wasi:filesystem/imports@0.2.3;
      include wasi:http/imports@0.2.3;
      include wasi:io/imports@0.2.3;
      include wasi:random/imports@0.2.3;
      include wasi:sockets/imports@0.2.3;

      export http-plugin;
  }
  ```
) <img-world>

Сервер загружает WASM-компоненты через движок Wasmtime @wasmtime-docs, выбранный
по среди других движков как самый близкий к стандартам WASI @zhang-runtimes.
Wasmtime транслирует байткод в машинный код целевой платформы с помощью
компилятора Cranelift. Каждый экземпляр плагина получает собственное линейное
адресное пространство памяти, недоступное другим компонентам системы. Доступ к
системным ресурсам осуществляется исключительно через WASI-интерфейсы, что
исключает прямое взаимодействие с операционной системой.

== 1.2 Организация пула плагинов

Центральным элементом архитектуры является структура PluginPool, управляющая
жизненным циклом загруженных плагинов. При инициализации сервера выполняется
сканирование директории plugins и загрузка всех обнаруженных модулей. Для
каждого плагина создаётся образ HttpPluginImage, содержащий предварительно
инстанцированный компонент и таблицу маршрутизации.

Маршрутизация запросов организована через библиотеку matchit, реализующую
алгоритм поиска по префиксному дереву. При регистрации плагина его эндпоинты
добавляются в общий роутер с учётом базового URL из конфигурации. Это позволяет
монтировать несколько плагинов под различными префиксами без конфликтов имён.

Для обработки каждого входящего запроса создаётся новый экземпляр плагина через
механизм InstancePre. Предварительная инстанциация компонента при загрузке
сервера сокращает накладные расходы на создание новых экземпляров. Каждый
экземпляр получает собственный Store с изолированным состоянием WASI-контекста.

== 1.3 WASI-интерфейсы и изоляция

Плагины взаимодействуют с внешним миром через стандартизированные
WASI-интерфейсы. В проекте подключены модули wasi:http для обработки
HTTP-запросов, wasi:config для доступа к конфигурационным переменным и
стандартный набор wasi:cli, wasi:filesystem, wasi:io. Каждый интерфейс
реализован хост-функциями в структуре State.

Конфигурационные переменные передаются плагину через WasiConfigVariables при
создании экземпляра. Это позволяет параметризовать поведение плагина без
перекомпиляции, например задавать base_url для монтирования под определённым
префиксом. Плагин читает эти переменные через wasi:config/store::get во время
исполнения.

Изоляция памяти гарантируется архитектурой WebAssembly на уровне виртуальной
машины. Плагин не может обратиться к памяти хост-процесса или других плагинов.
Передача данных между хостом и гостем происходит через линеаризацию в линейную
память компонента с последующей десериализацией на принимающей стороне.

== 1.4 UML-диаграммы

В приложениях А, Б, В, Г представлены диаграммы, описывающие:
1. компоненты сервера;
2. взаимодействие компонентов;
3. классы системы;
4. граф состояний сервер.
