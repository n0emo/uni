= 2. Обработка HTTP-запросов

== 2.1 Преобразование Hyper-запросов в WASI

Сервер построен на асинхронном фреймворке Hyper для обработки HTTP/1.1. При
поступлении запроса сервис WasselService выполняет поиск соответствующего
плагина через PluginPool и создаёт новый экземпляр для обработки. Запрос типа
hyper::Request преобразуется в WASI-представление через метод
new_incoming_request.

Преобразование включает копирование метода, пути, заголовков и тела запроса в
структуры данных WASI. Для тела создаётся поток, из которого плагин может читать
данные порциями. Схема HTTP определяется на основе конфигурации TLS, хотя в
текущей реализации используется исключительно незашифрованный HTTP.

Ответ формируется через механизм ResponseOutparam, представляющий собой канал
для передачи результата из плагина обратно в хост. Плагин создаёт
OutgoingResponse, устанавливает статусный код и заголовки, затем записывает тело
через OutgoingBody. После завершения записи канал закрывается и хост получает
готовый ответ для отправки клиенту.

== 2.2 Жизненный цикл обработки запроса

Обработка начинается с извлечения пути из URI и поиска в роутере идентификатора
плагина. Если маршрут не найден, сервер немедленно возвращает статус 404 без
создания экземпляра плагина. При успешном поиске вызывается метод get_plugin,
который инстанцирует новый экземпляр из предзагруженного образа.

Экземпляр получает эксклюзивный доступ к Store через Mutex, что обеспечивает
потокобезопасность при асинхронном выполнении. Внутри критической секции
происходит преобразование запроса, создание параметра ответа и вызов
функции-обработчика плагина. Вызов осуществляется через типизированный
интерфейс, сгенерированный макросом bindgen из WIT-описания.

После вызова обработчика необходимо дождаться записи ответа через канал
ResponseOutparam. Плагин может писать тело ответа асинхронно, поэтому хост
блокируется на ожидании результата из oneshot-канала. Полученный WASI-ответ
преобразуется обратно в hyper::Response с маппингом кодов ошибок в
соответствующие HTTP-статусы.

== 2.3 Маршрутизация и композиция

Система маршрутизации поддерживает монтирование плагинов под произвольными
префиксами через параметр base_url в конфигурации. При регистрации эндпоинтов
плагина их пути конкатенируются с базовым URL, что позволяет избежать конфликтов
между плагинами. Например, два плагина могут регистрировать путь "/", но быть
смонтированы под "/api/v1" и "/api/v2".

Внутри плагина маршрутизация выполняется через возврат списка Endpoint из
функции get-endpoints. Каждая запись содержит путь относительно базового URL и
имя экспортируемой функции-обработчика. Сервер извлекает эти функции из таблицы
экспортов компонента и сохраняет ссылки для последующих вызовов.

Композиция плагинов происходит на уровне HTTP-роутера без взаимодействия между
компонентами. Каждый плагин обрабатывает только свои маршруты и не имеет доступа
к другим плагинам. Для организации цепочек обработчиков или middleware
потребуется расширение архитектуры с введением механизма передачи управления
между компонентами.
