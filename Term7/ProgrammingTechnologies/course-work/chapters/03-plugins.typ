= 3. Реализация плагинов

== 3.1 Rust-плагин с использованием wit-bindgen

Разработка плагина на Rust начинается с определения WIT-интерфейса в файле
plugin.wit, описывающего экспортируемые функции. Макрос wit_bindgen::generate!
анализирует это описание и генерирует типы и трейты для реализации. Разработчик
создаёт структуру, реализующую трейт Guest, и экспортирует её через макрос
export!.

В примере hello-plugin определены два обработчика handle-hello и handle-bye,
возвращающие текстовые ответы. Функция-помощник handle формирует HTTP-ответ
через WASI-примитивы: создание OutgoingResponse с пустыми заголовками, установка
статусного кода 200, получение потока записи тела и запись UTF-8 строки.

Завершение записи происходит через вызов OutgoingBody::finish.

Доступ к конфигурационным переменным демонстрируется чтением base_url через
wasi::config::store::get. Это позволяет плагину адаптировать своё поведение под
окружение без хардкодинга значений. Компиляция плагина выполняется с целевой
архитектурой wasm32-wasi и типом библиотеки cdylib для генерации WASM-модуля.

== 3.2 Python-плагин через componentize-py

Python-плагины создаются с использованием инструмента componentize-py,
транслирующего Python-код в WebAssembly компонент. Разработчик наследует классы
из сгенерированных привязок и реализует методы протокола. В примере
python-plugin используется шаблонизатор Jinja2 для рендеринга HTML-страниц.

Особенностью Python-плагинов является необходимость упаковки зависимостей внутрь
WASM-компонента. Библиотека Jinja2 и её транзитивные зависимости включаются в
итоговый модуль, что увеличивает его размер. Чтение статических файлов
осуществляется через pathlib с разрешением путей относительно расположения
исходного файла плагина.

Обработка запроса следует той же схеме, что и в Rust: создание ответа, установка
заголовков, запись тела через контекстный менеджер потока записи. Python-обёртки
скрывают низкоуровневые детали WASI-интерфейса, предоставляя идиоматичный API.
Компиляция выполняется инструментом componentize-py с указанием мира и точки
входа.

== 3.3 Метаданные и конфигурация плагинов

Каждый плагин сопровождается файлом plugin.toml с метаданными: идентификатор,
название, версия и опциональное описание. Сервер использует идентификатор для
связывания плагина с конфигурационными переменными из config.toml. Название и
версия предназначены для административных целей и логирования.

Конфигурация плагина задаётся в секции plugins основного файла конфигурации
сервера. Для каждого идентификатора можно определить произвольный набор пар
ключ-значение, передаваемых плагину через WasiConfigVariables. Обязательным
параметром является base_url, определяющий префикс монтирования плагина в общем
пространстве маршрутов.

При загрузке сервер читает plugin.toml для извлечения метаданных и plugin.wasm
для получения исполняемого кода. Отсутствие любого из этих файлов приводит к
ошибке загрузки плагина с записью в лог. Валидация WIT-интерфейса происходит при
попытке извлечения экспорта wassel:plugin/http-plugin из компонента.
